<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> Cpp Resource Management &middot; Hank&#39;s Blog </title>


<link rel="stylesheet" href="/zhengyhn.githuh.io/css/slim.css">
<link rel="stylesheet" href="/zhengyhn.githuh.io/css/highlight.min.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="Hank&#39;s Blog" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="/zhengyhn.githuh.io">Hank&#39;s Blog</a></h1>
  <p class="site-tagline">坚持做一件事，然后静静地等待时间的回报</p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
       
	  <li class="spacer">&ac;</li>
  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="posts">
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.githuh.io/post/cpp-resource-management/">Cpp Resource Management</a></h2>
          <span class="post-date">May 14, 2016 </span>
          <div class="post-content">
            

<p>I always forget freeing a memory that allocated from the heap.And I always
forget closing the file handler.</p>

<p>Resources include file descriptors, mutex locks, fonts, brushes, database
connections and network sockets.</p>

<p>I think less programmers can remember closing a file handler, especially
in a large project.</p>

<p>Nowadays, many programming languages have the garbage collection function.
In C++, since the destructor will be automatically called, we can release
the resources automatically if we put the resource into an object.</p>

<p>How can do that?Use the <em>smart pointer</em>:<code>std::auto_ptr</code>.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;memory&gt;

int
main(int argc, char **argv)
{
    int *num = NULL;
    {
        num = new int();
        std::auto_ptr&lt;int&gt; ap(num);
    }
    // delete num;

    return 0;
}
</code></pre>

<p>If trying to delete num after the block, that will be a double free error.</p>

<p>Reference from <a href="http://www.cplusplus.com/reference/memory/auto_ptr/">cplusplus.com</a>, <code>auto_ptr</code> is deprecated in C++11 and is replaced by <code>unique_ptr</code>.
But they are similar.</p>

<p>However, multiple <code>auto_ptr</code> cannot contain the same object.</p>

<p>Here is the test program.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;memory&gt;

int
main(int argc, char **argv)
{
    int *num = NULL;
    {
        num = new int();
        std::auto_ptr&lt;int&gt; ap1(num);
        std::auto_ptr&lt;int&gt; ap2(ap1);

        printf(&quot;%p\n&quot;, &amp;ap1);
        ap1 = ap2;
        printf(&quot;%p\n&quot;, &amp;ap2);
    }
    // delete num;

    return 0;
}
</code></pre>

<p>And here is the gdb debug output information.</p>

<pre><code>Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe6e8) at test.cpp:7
7       int *num = NULL;
(gdb) n
9       num = new int();
(gdb) n
10      std::auto_ptr&lt;int&gt; ap1(num);
(gdb) n
11      std::auto_ptr&lt;int&gt; ap2(ap1);
(gdb) p ap1
$1 = {_M_ptr = 0x601010}
(gdb) p ap2
$2 = {_M_ptr = 0x7fff00000001}
(gdb) n
13      printf(&quot;%p\n&quot;, &amp;ap1);
(gdb) p ap1
$3 = {_M_ptr = 0x0}
(gdb) p ap2
$4 = {_M_ptr = 0x601010}
(gdb) n
0x7fffffffe5e0
14      ap1 = ap2;
(gdb) p ap1
$5 = {_M_ptr = 0x0}
(gdb) p ap2
$6 = {_M_ptr = 0x601010}
(gdb) n
15      printf(&quot;%p\n&quot;, &amp;ap2);
(gdb) p ap1
$7 = {_M_ptr = 0x601010}
(gdb) p ap2
$8 = {_M_ptr = 0x0}
(gdb) 
</code></pre>

<p>But there are another smart pointer that can do this.It&rsquo;s the
<code>std::tr1::shared_ptr</code>.Mutiple shared_ptr can contain the same object.</p>

<p>The testing program is as follow.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;tr1/memory&gt;

int
main(int argc, char **argv)
{
    int *num = NULL;
    {
        num = new int();
        std::tr1::shared_ptr&lt;int&gt; ap1(num);
        std::tr1::shared_ptr&lt;int&gt; ap2(ap1);

        printf(&quot;%p\n&quot;, &amp;ap1);
        ap1 = ap2;
        printf(&quot;%p\n&quot;, &amp;ap2);
    }

    return 0;
}
</code></pre>

<p>And the gdb debug information is:</p>

<pre><code>Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe6e8) at test.cpp:7
7       int *num = NULL;
(gdb) n
9       num = new int();
(gdb) n
10      std::tr1::shared_ptr&lt;int&gt; ap1(num);
(gdb) n
11      std::tr1::shared_ptr&lt;int&gt; ap2(ap1);
(gdb) n
13      printf(&quot;%p\n&quot;, &amp;ap1);
(gdb) p ap1
$1 = std::tr1::shared_ptr (count 2, weak 0) 0x602010
(gdb) p ap2
$2 = std::tr1::shared_ptr (count 2, weak 0) 0x602010
(gdb) n
0x7fffffffe5d0
14      ap1 = ap2;
(gdb) n
15      printf(&quot;%p\n&quot;, &amp;ap2);
(gdb) p ap1
$3 = std::tr1::shared_ptr (count 2, weak 0) 0x602010
(gdb) p ap2
$4 = std::tr1::shared_ptr (count 2, weak 0) 0x602010
</code></pre>

<p>We can see that both of <code>ap1</code> and <code>ap2</code> point to the same object.</p>

<p>The <code>auto_ptr</code> and <code>shared_ptr</code> use <code>delete</code> but not <code>delete[]</code>,
so they don&rsquo;t support array.But the <code>unique_ptr</code> support.</p>

<p>Sometimes, the resource may be a mutex, and we don&rsquo;t want to remember
unlocking the mutex every time we lock it.So a resource management object
may be:</p>

<pre><code>#include &lt;cstdio&gt;

typedef int Mutex;

void
lock(Mutex *p)
{
    printf(&quot;Locking...\n&quot;);
}

void
unlock(Mutex *p)
{
    printf(&quot;Unlocked\n&quot;);
}

class Lock {
public:
    explicit Lock(Mutex *p)
        :pMutex(p)
    {
        lock(pMutex);
    }
    ~Lock()
    {
        unlock(pMutex);
    }
private:
    Mutex *pMutex;
};

int
main(int argc, char **argv)
{
    Mutex m;
    {
        Lock ml(&amp;m);
    }

    return 0;
}
</code></pre>

<p>However, when we copy the <code>Lock</code> object, problems appear.</p>

<pre><code>Lock ml2(ml);
</code></pre>

<p>The default copy constructor will directly copy the pointer <code>pMutex</code> to
the target object.So we should let the object uncopyable.</p>

<pre><code>private:
Lock(const Lock&amp;);
Lock&amp;
operator=(const Lock&amp;);

Mutex *pMutex;
</code></pre>

<p>Multiple objects can use the same resource, so the resource may be existed
until the last object has been destroyed.The <code>tr1::shared_ptr</code> provide a
<code>deleter</code> and its <strong>shared ability</strong> to solve this problem.</p>

<pre><code>class Lock {
public:
    explicit Lock(Mutex *p)
        :pMutex(p, unlock)
    {
        lock(pMutex.get());
    }
private:
    Lock(const Lock&amp;);
    Lock&amp;
    operator=(const Lock&amp;);

    std::tr1::shared_ptr&lt;Mutex&gt; pMutex;
};
</code></pre>

<h2 id="provide-access-to-raw-resources:29d34860a4144be93b1626862a2c23af">Provide access to raw resources</h2>

<p>Sometimes we may only want to access the raw resource but the object that
contains the resource.For example:</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;tr1/memory&gt;

typedef int Mutex;

static Mutex *
createMutex()
{
    static Mutex *p = new Mutex();

    return p;
}

int
main(int argc, char **argv)
{
    std::tr1::shared_ptr&lt;Mutex&gt; pMutex;

    printf(&quot;%d\n&quot;, pMutex);

    return 0;
}
</code></pre>

<p>Therefore, we must provide a method to access the raw resource.Like this.</p>

<pre><code>    printf(&quot;%d\n&quot;, pMutex.get());
</code></pre>

<p>There are two ways, one is explicit and the other is implicit.</p>

<pre><code>class MutexManager {
public:
    explicit MutexManager(Mutex* p)
        :p_(p)
    { }
    ~MutexManager()
    {
        delete p_;
    }
    Mutex
    get() const
    {
        return *p_;
    }
private:
    Mutex *p_;
};

int
main(int argc, char **argv)
{
    MutexManager mm(createMutex());

    printf(&quot;%d\n&quot;, mm.get());

    return 0;
}
</code></pre>

<p>This one above is exciplit conversion.And this one below is implicit.</p>

<pre><code>class MutexManager {
public:
    explicit MutexManager(Mutex* p)
        :p_(p)
    { }
    ~MutexManager()
    {
        delete p_;
    }
    operator Mutex() const
    {
        return *p_;
    }
private:
    Mutex *p_;
};

void
print(Mutex m)
{
    printf(&quot;%d\n&quot;, m);
}

int
main(int argc, char **argv)
{
    MutexManager mm(createMutex());

    print(mm);

    return 0;
}
</code></pre>

<p>It&rsquo;s obviously that the explicit method is safer and the implicit method is
more convenient for clients.</p>

<h2 id="keep-new-and-delete-in-the-same-form:29d34860a4144be93b1626862a2c23af">Keep new and delete in the same form</h2>

<p>We all know that the following code is wrong.</p>

<pre><code>std::string *str = new std::string[10];
delete str;
</code></pre>

<p>We should use <code>delete []str;</code> instead of <code>delete str;</code>.</p>

<p>But how about this?</p>

<pre><code>#include &lt;iostream&gt;

typedef std::string Lines[4];

int
main(int argc, char **argv)
{
    std::string *p = new Lines;
    delete p;

    return 0;
}
</code></pre>

<p>If let me delete the pointer p, I will use this <code>delete p;</code>.But I am wrong.
I shouldn&rsquo;t look at the left of the pointer, that is, <code>std::string</code>.I should
look at the right of the <code>new</code>, that is, <code>Lines</code>.So, in this case, we
should use <code>delete []p;</code>.</p>

<p>Avoid typedef for array types, use <code>vector</code> instead.</p>

          </div>
        </div>
        <div class="pagination"> 
        </div>
      </div>
    </div>
    
    <div class="footer">
  <p>Powered by <a href="http://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
</div>

  </div>
  <script src="/zhengyhn.githuh.io/js/slim.js"></script>
  <script src="/zhengyhn.githuh.io/js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
</body>

</html>
