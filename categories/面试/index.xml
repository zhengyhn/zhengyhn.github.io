<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>面试 on Hank&#39;s Blog</title>
    <link>http://zhengyhn.github.io/categories/%E9%9D%A2%E8%AF%95/</link>
    <description>Recent content in 面试 on Hank&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 May 2016 20:50:49 +0800</lastBuildDate>
    <atom:link href="http://zhengyhn.github.io/categories/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>c plus plus interview review</title>
      <link>http://zhengyhn.github.io/post/c-plus-plus-interview-review/</link>
      <pubDate>Fri, 27 May 2016 20:50:49 +0800</pubDate>
      
      <guid>http://zhengyhn.github.io/post/c-plus-plus-interview-review/</guid>
      <description>

&lt;p&gt;这是我看了《C笔试面试宝典》一书的笔记&lt;/p&gt;

&lt;h1 id=&#34;new-delete-malloc-free的关系:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;new, delete, malloc, free的关系&lt;/h1&gt;

&lt;p&gt;new和delete是C++的 &lt;strong&gt;运算符&lt;/strong&gt; ，new调用构造函数，delete调用析构函数。&lt;/p&gt;

&lt;p&gt;malloc和delete是C运行库的函数。&lt;/p&gt;

&lt;h1 id=&#34;delete和delete-的区别:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;delete和delete[]的区别&lt;/h1&gt;

&lt;p&gt;delete只会调用一次析构函数，delete[]则会调用每个成员的析构函数。&lt;/p&gt;

&lt;p&gt;写程序一测:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

class Computer {
 private:
  std::string name;
 public:
  Computer();
  ~Computer();
};

Computer::Computer() { }

Computer::~Computer() { }

int main(int argc, char *argv[])
{
  Computer *cs = new Computer[5];
  Computer *c = new Computer;
  int *integers = new int[5];
  int *i = new int;

  delete[] i;
  delete[] integers;
  delete[] cs;
  delete[] c;

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现编译可以通过，但是运行会Segment Fault。gdb一下，发现在delete[]
c时出错了。&lt;/p&gt;

&lt;p&gt;原因是，对于基本数据类型，delete[]能代替delete，对于自定义的类型，则要严格区分，
new[]完之后用delete[]释放，new完之后用delete释放。&lt;/p&gt;

&lt;h1 id=&#34;继承和组合的优缺点:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;继承和组合的优缺点&lt;/h1&gt;

&lt;p&gt;引用自
&lt;a href=&#34;http://www.cnblogs.com/nuaalfm/archive/2010/04/23/1718453.html&#34;&gt;这里&lt;/a&gt;
。&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;45%&#34; /&gt;
&lt;col width=&#34;54%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;组合 关 系&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;继 承 关 系&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;优点：具有较好的可扩展性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;缺点：支持扩展，但是往往以增加系统结构的复杂度为代价&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;缺点：不支持动态继承。在运行时，子类无法选择不同的父类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;缺点：子类不能改变父类的接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;缺点：整体类不能自动获得和局部类同样的接口&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;优点：子类能自动继承父类的接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;缺点：创建整体类的对象时，需要创建所有局部类的对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;优点：创建子类的对象时，无须创建父类的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;引用:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;引用&lt;/h1&gt;

&lt;p&gt;不能建立数组的引用。引用没有定义新的变量，不占用内存空间。&lt;/p&gt;

&lt;h1 id=&#34;关联-聚合和组合:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;关联，聚合和组合&lt;/h1&gt;

&lt;p&gt;关联是两个类的一般性关联，如老师和学生。&lt;/p&gt;

&lt;p&gt;聚合是has-a关系，聚合类不需要对被聚合类负责，用空的菱形表示，实现如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A {

};
class B {
    A *a;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组合是contains-a关系，组合类和被组合类有相同的生命周期，组合类要对被组合类负责，
用实的菱形表示，实现如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A {

};
class B {
    A a;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;初始化列表:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;初始化列表&lt;/h1&gt;

&lt;p&gt;当类中含有const和引用成员变量时，基类构造函数只能使用初始化列表来初始化， 但是&lt;br /&gt;
&lt;code&gt;const int&amp;amp; a;&lt;/code&gt; 这种就可以用赋值的方法。&lt;/p&gt;

&lt;h1 id=&#34;类型安全:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;类型安全&lt;/h1&gt;

&lt;p&gt;c++不是类型安全的，因为不同类型的指针之间可以强制转换。&lt;/p&gt;

&lt;h1 id=&#34;空类:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;空类&lt;/h1&gt;

&lt;p&gt;当一个类没有任何成员时，大小是1byte，这个字节是用来区分这个类的不同对象的。&lt;/p&gt;

&lt;h1 id=&#34;逻辑地址-to-物理地址:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;逻辑地址 to 物理地址&lt;/h1&gt;

&lt;p&gt;给出的逻辑地址格式是这样的,
段地址:段内偏移地址，那么真实的地址（物理地址） 是： 段地址 * 10H +
段内偏移地址。当然，这只适合于Intel 8086。&lt;/p&gt;

&lt;h1 id=&#34;4种类型转换:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;4种类型转换&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;const_cast，把const的变量变成非const的，用法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;新变量  = const_cast&amp;lt;类型&amp;gt;(变量);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;static_cast,
用于基本类型的转换，不能用于无关类型（不是基类与子类）之间的
指针的转换&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dynamic_cast,
运行时会有安全检查，用于基类与子类之间的转换，常用于多态&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;reinterpret_cast，重新解释类型，没有转换，常用于函数指针的转换。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;数组作参数:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;数组作参数&lt;/h1&gt;

&lt;p&gt;当数组作为参数传递时，它会退化成同类型的指针。&lt;/p&gt;

&lt;h1 id=&#34;override和隐藏:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;override和隐藏&lt;/h1&gt;

&lt;p&gt;override，基类中必须要有virtual。&lt;/p&gt;

&lt;p&gt;如果基类函数名没有virtual，子类函数与父类函数签名一样，则称隐藏。&lt;/p&gt;

&lt;p&gt;不管基类函数名有没有virtual，子类函数名一样，签名不一样，则也称隐藏。&lt;/p&gt;

&lt;h1 id=&#34;求两个数中的最大的那个数:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;求两个数中的最大的那个数&lt;/h1&gt;

&lt;p&gt;不能用判断(if, :?, switch)。答案是用abs函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;((a + b) + abs(a - b)) / 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而我觉得这种方法不好，因为用到了库函数，库函数里面还可能也要判断，其实是换汤不换药。&lt;/p&gt;

&lt;p&gt;我问了同学，他想到了下面的方法，我觉得很好:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int max(int a, int b);

int main(int argc, char *argv[])
{
     int a = 9999, b = 23;

     printf(&amp;quot;%d\n&amp;quot;, max(a, b));

     return 0;
}

int max(int a, int b)
{
     int c = a - b;
     int flag = (unsigned)c &amp;gt;&amp;gt; (sizeof(int) * 8 - 1);

     return (1 - flag) * a + flag * b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据负数与正数的符号位的不一样，而得出那个数。&lt;/p&gt;

&lt;h1 id=&#34;打印源文件的文件名和当前行号:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;打印源文件的文件名和当前行号&lt;/h1&gt;

&lt;p&gt;在C/C++中，可以用__FILE__和__LINE__，由编译器来识别。&lt;/p&gt;

&lt;h1 id=&#34;main函数执行完之后还能执行代码:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;main函数执行完之后还能执行代码？&lt;/h1&gt;

&lt;p&gt;居然是可以的！ &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;
中有一个奇葩的库函数叫on_exit，在linux下的man page中， 定义如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int on_exit(void (*function)(int , void *), void *arg);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传进去一个函数指针，和一个参数，这个函数必须是2个参数，分别是int和void*类型的，
可以调用多个，以LIFO形式执行，
on_exit在任何地方调用都只会在main函数结束之后才会执行。 测试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void one(int status, void *arg);
void two(int status, void *arg);

int main(int argc, char *argv[])
{
     printf(&amp;quot;top\n&amp;quot;);
     on_exit(two, NULL);
     on_exit(one, NULL);

     printf(&amp;quot;It may be the last one.\n&amp;quot;);

     return 0;
}

void one(int status, void *arg)
{
     printf(&amp;quot;one\n&amp;quot;);
}

void two(int status, void *arg)
{
     printf(&amp;quot;two\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;书上说的是 &lt;code&gt;_onexit&lt;/code&gt;
，根据我找的资料，这函数应该只有在windows的VC中才有。&lt;/p&gt;

&lt;h1 id=&#34;判断是由c编译器编译还是由c-编译器编译:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;判断是由C编译器编译还是由C++编译器编译&lt;/h1&gt;

&lt;p&gt;使用一个宏 &lt;code&gt;__cplusplus&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef __cplusplus
...
#else
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;求n个数中第k大的数:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;求n个数中第k大的数&lt;/h1&gt;

&lt;p&gt;我智商低，只能想到普通的办法，就是选择排序的外面循环K次。不过不能因为这样而找不到工作啊，
学习了大牛的算法：&lt;/p&gt;

&lt;p&gt;吸取快排中的思想，随机取一个数，把比它小的数放到左边，比它大的数放到右边，
如果运气非常好，它的下标i刚好是n - k - 1，则它就是第k大的数，如果i小于 n
- k - 1，则第k大的数在左边，否则在右边，再分为子问题进行求解。&lt;/p&gt;

&lt;p&gt;写了很久终于写出来了，要是在面试的时候，估计写不出来:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int get_maxk(int *arr, int n, int k);
void swap(int *arr, int i, int j);

int main(int argc, char *argv[])
{
     int a[10];
     int i;

     srand(time(NULL));
     for (i = 0; i &amp;lt; 10; i++) {
          a[i] = rand();
     }
     for (i = 1; i &amp;lt;= 10; i++) {
          printf(&amp;quot;%d\n&amp;quot;, get_maxk(a, 10, i));
     }

     return 0;
}

int get_maxk(int *arr, int n, int k)
{
     int pivot, last_left, i;

     if (k &amp;gt; n) {
          fprintf(stderr, &amp;quot;k can&#39;t be larger than n\n&amp;quot;);
          exit(1);
     } else if (k == n) {
          return arr[0];
     }
     pivot = 0;
     last_left = pivot;
     for (i = 1; i &amp;lt; n; i++) {
          if (arr[i] &amp;lt; arr[pivot]) {
               last_left++;
               swap(arr, last_left, i);
          }
     }
     swap(arr, pivot, last_left);
     if ((n - last_left) == k) {
          return arr[k];
     } else if ((n - last_left) &amp;gt; k) {
          return get_maxk(arr + last_left + 1, n - last_left - 1, k);
     } else {
          return get_maxk(arr, last_left, k - (n - last_left));
     }
}

void swap(int *arr, int i, int j)
{
     int temp;

     if (i == j) {
          return;
     }
     temp = arr[i];
     arr[i] = arr[j];
     arr[j] = temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;判断单链接有环:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;判断单链接有环&lt;/h1&gt;

&lt;p&gt;想到这个方法的人就是神！&lt;/p&gt;

&lt;p&gt;用两个指针，一个每次走一步，另外一个每次走两步，如果有环必定重合，
否则走两步的那个指针将到达终点。&lt;/p&gt;

&lt;h1 id=&#34;传值还是传地址:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;传值还是传地址&lt;/h1&gt;

&lt;p&gt;看下面的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void func(char *a)
{
    a = (char *)malloc(10);
}

int main(void)
{
    char *a = NULL;
    func(a);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完主函数后，a还是NULL！a不是传进去申请了空间吗？我之前也是这样认为的，
后来发现， 其实func函数的那个参数是以传值的方式传进去的，而不是传地址！
如果要传地址的话， 应该是 &lt;code&gt;char **a，func(&amp;amp;a)&lt;/code&gt; 这样才行！&lt;/p&gt;

&lt;h1 id=&#34;extern-c:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;extern &amp;ldquo;C&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;这个是用于C/C++混合编程的，当引用C语言代码时在函数前面加上。&lt;/p&gt;

&lt;h1 id=&#34;内联函数:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;内联函数&lt;/h1&gt;

&lt;p&gt;编译器在编译内联函数时会对参数类型进行检查。&lt;/p&gt;

&lt;h1 id=&#34;堆栈溢出的原因:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;堆栈溢出的原因&lt;/h1&gt;

&lt;p&gt;分配了内存没有释放 递归层次太深&lt;/p&gt;

&lt;h1 id=&#34;唯一不能声明为虚函数的函数:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;唯一不能声明为虚函数的函数&lt;/h1&gt;

&lt;p&gt;构造函数！PS：析构函数可以声明为虚函数。&lt;/p&gt;

&lt;h1 id=&#34;error:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;#error&lt;/h1&gt;

&lt;p&gt;当预处理执行到#error时，会停止编译，并给出自定义的错误信息&lt;/p&gt;

&lt;h1 id=&#34;指针-数组:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;指针&amp;amp;数组&lt;/h1&gt;

&lt;p&gt;指向数组的指针:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int (*a)[10];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指向函数（返回值为int,1个int参数）的指针:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int (*a)(int);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;volatile:59a5f49c2dadf82bb0327bad32ec766b&#34;&gt;volatile&lt;/h1&gt;

&lt;p&gt;修饰的变量，表明可能会被意想不到地改变，因此编译器不会从寄存器的备份中读取（因为
内存中的值可能已经被改变了），而要每次小心地从内存中读取。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>