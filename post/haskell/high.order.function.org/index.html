<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> 高阶函数 &middot; Hank&#39;s Blog </title>


<link rel="stylesheet" href="http://zhengyhn.github.io//css/slim.css">
<link rel="stylesheet" href="http://zhengyhn.github.io//css/highlight.min.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="Hank&#39;s Blog" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="http://zhengyhn.github.io/">Hank&#39;s Blog</a></h1>
  <p class="site-tagline">坚持做一件事，然后静静地等待时间的回报</p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
       
	  <li class="spacer">&ac;</li>

      <li><a href="https://github.com/zhengyhn">Github</a></li>  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="posts">
        <div class="post">
          <h2 class="post-title"><a href="http://zhengyhn.github.io/post/haskell/high.order.function.org/">高阶函数</a></h2>
          <span class="post-date">Mar 11, 2013 </span>
          <div class="post-content">
            

<h1 id="curried-function">curried function</h1>

<p>我还是直接翻译成“用咖啡煮的函数吧”。 有一个有趣的现象：</p>

<pre><code class="language-haskell">Prelude&gt; max 1 2
2
Prelude&gt; (max 1) 2
2
</code></pre>

<p>我刚开始觉得这太不可思议了，max
1居然可以执行，而且它的返回值还拿2来当参数！
原来这个函数可以写成下面这两种形式：</p>

<pre><code class="language-haskell">Prelude&gt; :t max
max :: Ord a =&gt; a -&gt; a -&gt; a
Prelude&gt; :t max
max :: Ord a =&gt; a -&gt; (a -&gt; a)
</code></pre>

<p>第二种，如果给max传一个参数x，则它返回一个函数，这个函数会接受一个参数y返回和x
比较之后的最大值。
这意味着我们可以传部分参数给一个函数。是不是只有库函数才这样的呢？不是！</p>

<pre><code class="language-haskell">-- addThree - adds three numbers, returns their sum
addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a
addThree x y z = x + y + z            
</code></pre>

<p>运行结果：</p>

<pre><code class="language-haskell">*Main&gt; addThree 1 2 3
6
*Main&gt; ((addThree 1) 2) 3
6
</code></pre>

<p>这令我非常震惊！ 中缀函数也能有这种用法：</p>

<pre><code class="language-haskell">{- isUpper - if a character is uppercase, return True,
             otherwise, return False.
-}
isUpper :: Char -&gt; Bool
isUpper = (`elem` ['A'..'Z'])
</code></pre>

<p>虽然只有一个参数，但是也能看到基本的形式是加一个括号，称为section。</p>

<h1 id="其它的高阶函数">其它的高阶函数</h1>

<p>函数可以接受函数作为参数，也可以返回函数。
实现一个标准库函数zipWith，接受一个函数，两个list，根据这个函数的作用返回
2个list合并后的效果。</p>

<pre><code class="language-haskell">zip_with :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
zip_with _ [] _ = []
zip_with _ _ [] = []
zip_with func (xFirst:xRest) (yFirst:yRest) =
    (func xFirst yFirst) : (zip_with func xRest yRest)
</code></pre>

<p>使用一下：</p>

<pre><code class="language-haskell">*Main&gt; zip_with (*) [1, 2] [3, 4]
[3,8]
*Main&gt; zip_with max [1, 2] [3, 4]
[3,4]
</code></pre>

<p>这就是通用的函数，太厉害了！</p>

<h1 id="一些库函数">一些库函数</h1>

<h2 id="map">map</h2>

<p>接受一个函数和一个list作为参数，把这个函数作用于list中的每个函数。</p>

<pre><code class="language-haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ [] = []
map f (first:rest) = f first : map f rest
</code></pre>

<p>关键是它的应用，这个函数用起来非常方便。</p>

<pre><code class="language-haskell">*Main&gt; map fst [(1, 2), (3, 4)]
[1,3]
*Main&gt; map (* 2) [1, 2, 3]
[2,4,6]
</code></pre>

<h2 id="filter">filter</h2>

<p>顾名思义，是用来过滤的，接受一个predicate，即判断函数，和一个list，返回一个
满足条件的list。</p>

<pre><code class="language-haskell">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
filter _ [] = []
filter predicate (first:rest)
    | predicate first = first : filter predicate rest
    | otherwise = filter predicate rest
</code></pre>

<p>应用：</p>

<pre><code class="language-haskell">*Main&gt; filter' (&gt; 3) [1, 2, 3, 4]
[4]
</code></pre>

<p>上面这2个函数都可以通过list
comprehension来代替。但是使用这样的函数会更容易 理解，可读性更强。</p>

<h1 id="lambdas">lambdas</h1>

<p>其实就是匿名函数(anonymous function)。比如： map (+3) [1, 2, 3] 和 map
(\x -&gt; x + 3) [1, 2, 3]是等价的。
使用\来表示匿名函数，上例中，传入参数x，返回值为x + 3。</p>

          </div>
        </div>
        <div class="pagination">
          <a class="btn previous " href="http://zhengyhn.github.io/post/algorithm/quick.exp/"> Prev</a>  
          <a class="btn next " href="http://zhengyhn.github.io/post/clang/function.org/"> Next</a> 
        </div>
      </div>
    </div>
    
    <div class="footer">
  <p>Powered by <a href="http://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
</div>

  </div>
  <script src="http://zhengyhn.github.io//js/slim.js"></script>
  <script src="http://zhengyhn.github.io//js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
</body>

</html>
