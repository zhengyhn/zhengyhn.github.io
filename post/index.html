<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> Posts &middot; Hank&#39;s Blog </title>


<link rel="stylesheet" href="/zhengyhn.github.io/css/slim.css">
<link rel="stylesheet" href="/zhengyhn.github.io/css/highlight.min.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="zhengyhn.github.io/post/index.xml" rel="alternate" type="application/rss+xml" title="Hank&#39;s Blog" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="/zhengyhn.github.io">Hank&#39;s Blog</a></h1>
  <p class="site-tagline">坚持做一件事，然后静静地等待时间的回报</p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
       
	  <li class="spacer">&ac;</li>
  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="posts">
         
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/c-plus-plus-interview-review/">c plus plus interview review</a></h2>
          <span class="post-date">May 27, 2016</span>
		  
			<span class="post-tags">
		  	
			          #<a href="/tags/%E9%9D%A2%E8%AF%95">面试</a>&nbsp;
		  	
		    </span>
		  
		  
		  	<div class="summary">
				这是我看了《C笔试面试宝典》一书的笔记 new, delete, malloc, free的关系 new和delete是C++的 运算符 ，new调用构造函数，delete调用析构函数。 malloc和delete是C运行库的函数。 delete和delete[]的区别 delete只会调用一次析构函数，delete[]则会调用每个成员的析构函数。 写程序一测: #include &lt;iostream&gt; #include &lt;string&gt; class Computer { private: std::string name; public: Computer(); ~Computer(); }; Computer::Computer() { } Computer::~Computer() { } int main(int argc, char *argv[]) { Computer *cs = new Computer[5]; Computer *c = new Computer; int *integers = new int[5]; int *i = new int; delete[] i; delete[] integers; delete[] cs; delete[] c; return 0; } 发现编译可以通过，但是运行会Segment Fault。gdb一下，发现在delete[] c时出错了。 原因是，对于基本数据类型，delete[]能代替delete，对于自定义的类型，则要严格区分， new[]完之后用delete[]释放，new完之后用delete释放。 继承和组合的优缺点 引用自 这里 。 组合 关 系 继 承 关 系 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 优点：具有较好的可扩展性 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 缺点：不支持动态继承。在运行时，子类无法选择不同的父类 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 缺点：子类不能改变父类的接口 缺点：整体类不能自动获得和局部类同样的接口 优点：子类能自动继承父类的接口 缺点：创建整体类的对象时，需要创建所有局部类的对象 优点：创建子类的对象时，无须创建父类的对象 引用 不能建立数组的引用。引用没有定义新的变量，不占用内存空间。 关联，聚合和组合 关联是两个类的一般性关联，如老师和学生。 聚合是has-a关系，聚合类不需要对被聚合类负责，用空的菱形表示，实现如下: class A { }; class B { A *a; }; 组合是contains-a关系，组合类和被组合类有相同的生命周期，组合类要对被组合类负责， 用实的菱形表示，实现如下: class A { }; class B { A a; }; 初始化列表 当类中含有const和引用成员变量时，基类构造函数只能使用初始化列表来初始化， 但是 const int&amp; a; 这种就可以用赋值的方法。 类型安全 c++不是类型安全的，因为不同类型的指针之间可以强制转换。 空类 当一个类没有任何成员时，大小是1byte，这个字节是用来区分这个类的不同对象的。 逻辑地址 to 物理地址 给出的逻辑地址格式是这样的, 段地址:段内偏移地址，那么真实的地址（物理地址） 是： 段地址 * 10H + 段内偏移地址。当然，这只适合于Intel 8086。 4种类型转换 const_cast，把const的变量变成非const的，用法: 新变量 = const_cast&lt;类型&gt;(变量); static_cast, 用于基本类型的转换，不能用于无关类型（不是基类与子类）之间的 指针的转换 dynamic_cast, 运行时会有安全检查，用于基类与子类之间的转换，常用于多态 reinterpret_cast，重新解释类型，没有转换，常用于函数指针的转换。 数组作参数 当数组作为参数传递时，它会退化成同类型的指针。 override和隐藏 override，基类中必须要有virtual。 如果基类函数名没有virtual，子类函数与父类函数签名一样，则称隐藏。 不管基类函数名有没有virtual，子类函数名一样，签名不一样，则也称隐藏。 求两个数中的最大的那个数 不能用判断(if, :?, switch)。答案是用abs函数: ((a + b) + abs(a - b)) / 2 而我觉得这种方法不好，因为用到了库函数，库函数里面还可能也要判断，其实是换汤不换药。 我问了同学，他想到了下面的方法，我觉得很好: #include &lt;stdio.h&gt; int max(int a, int b); int main(int argc, char *argv[]) { int a = 9999, b = 23; printf(&quot;%d\n&quot;, max(a, b)); return 0; } int max(int a, int b) { int c = a - b; int flag = (unsigned)c &gt;&gt; (sizeof(int) * 8 - 1); return (1 - flag) * a + flag * b; } 根据负数与正数的符号位的不一样，而得出那个数。 打印源文件的文件名和当前行号 在C/C++中，可以用__FILE__和__LINE__，由编译器来识别。 main函数执行完之后还能执行代码？ 居然是可以的！ &lt;stdlib.h&gt; 中有一个奇葩的库函数叫on_exit，在linux下的man page中， 定义如下: int on_exit(void (*function)(int , void *), void *arg); 传进去一个函数指针，和一个参数，这个函数必须是2个参数，分别是int和void*类型的， 可以调用多个，以LIFO形式执行， on_exit在任何地方调用都只会在main函数结束之后才会执行。 测试一下: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void one(int status, void *arg); void two(int status, void *arg); int main(int argc, char *argv[]) { printf(&quot;top\n&quot;); on_exit(two, NULL); on_exit(one, NULL); printf(&quot;It may be the last one.\n&quot;); return 0; } void one(int status, void *arg) { printf(&quot;one\n&quot;); } void two(int status, void *arg) { printf(&quot;two\n&quot;); } 书上说的是 _onexit ，根据我找的资料，这函数应该只有在windows的VC中才有。 判断是由C编译器编译还是由C++编译器编译 使用一个宏 __cplusplus: #ifdef __cplusplus ...
				<a class="read-more" href="/zhengyhn.github.io/post/c-plus-plus-interview-review/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/improve-code-readability/">improve code readability</a></h2>
          <span class="post-date">May 27, 2016</span>
		  
			<span class="post-tags">
		  	
			          #<a href="/tags/%E7%BC%96%E7%A8%8B">编程</a>&nbsp;
		  	
		    </span>
		  
		  
		  	<div class="summary">
				这是我读 &ldquo;the art of readable code&rdquo; 一书做的笔记 简化循环和逻辑 making control flow easy to read 下面的代码: if (length &gt;= 10) 要比: if (10 &lt;= length) 更容易看懂。这是很显然的。而在C语言中，有的人为了避免=与==的错误，常常把 代码写成: if (10 == length) 这种做法是为了避免错误的。其实在我看来，这明显是在掩饰自己区分不了=与==的 弱点，如果你真的理解赋值与相等的含义，就从来不会在比较相等的时候写成=，以 我使用C语言这么多年来，我从来没有犯过这种错误。上面的代码对于一个正常人来 说，很难理解，因为程序员首先是一个人，自然的语言是“长度等于10”，而不是 “10等于长度”，所以为了使代码更可读，我建议使用下面这种: if (lenght == 10) 上面的是有数字，有常量的比较，下面这个: while (bytes_received &lt; bytes_expected) 要比: while (bytes_expected &gt; bytes_received) 更容易看懂，因为第一个的阅读顺序符合人类的自然语言。 对于三目运算符?:，当表达式很长时不要使用。 不要使用do/while。当你阅读do/while的时候，因为你刚开始不知道条件，你会 把循环的主体阅读两次。我几乎不写do/while，而且我非常讨厌看do/while代码。 尽量不要使用嵌套的if/else，想尽办法使得只有一个层次。 breaking down giant expressions 利用宏来简化代码。看下面的例子: void AddStats(const Stats &amp;add_from, Stats *add_to) { add_to-&gt;set_total_memory(add_from.total_memory() + add_to-&gt;total_memory()); add_to-&gt;set_free_memory(add_from.free_memory() + add_to-&gt;free_memory()); add_to-&gt;set_swap_memory(add_from.swap_memory() + add_to-&gt;swap_memory()); } 不管是谁，看到这样的代码都会头晕，但是你会发现其实它们都在做同一件事: add_to-&gt;set_XXX(add_from.XXX + add_to-&gt;XXX); 于是，通过定义带参数的宏，可以简化成这样: void AddStats(const Stats &amp;add_from, Stats *add_to) { #define ADD_FIELD(field) \ add_to-&gt;set_#field(add_from.#field() + add_to-&gt;#field()) ADD_FIELD(total_memory); ADD_FIELD(free_memory); ADD_FIELD(swap_memory); } 这样不仅视觉上看起来舒服，而且理解起来非常容易。 variables and readability 可去除一些多余的变量 尽量缩小变量的范围，即使是全局变量，这样才能让程序更清晰。 在C++中，有这样一个例子: int size = list.size(); if (size &gt; 0) { cout &lt;&lt; size &lt;&lt; endl; } 假设后面再也没有用到size了，但是阅读代码的人会一直把这个变量记住，因为 他以为后面还会用到这个变量。我们可以把它改成这样: if ((int size = list.size()) &gt; 0) { cout &lt;&lt; size &lt;&lt; endl; } 当然，在C语言中，这需要C99的支持，当读者看完这段代码时，就会忘记这个变量， 因为后面已经用不上了。 作者是这样说的，但是我觉得这不太可能，因为写代码的人不可能预知未来，它总是 喜欢先把变量缓存起来，说不定以后还会用到，所以我不太赞成这种写法，除非是非常 简单，很明显后面用不上的变量。 尽量使变量只能改变一次(prefer write-once varaibles) 改善外层代码 packing informations into names choose specific words 书上说到getPage(url);这个函数的名字，根据我以前的看法，这绝对是一个好名字， 但是作者却批评这种命名方式。作者说，get太模糊了，我们看不出来它是从缓存中get还是 从数据库中get，还是从互联网上get。如果是从互联网上get,则应该使用fetchPage或者 downloadPage()。我觉得这个说法非常好，我以后给变量或者函数起名字的时候也要注意 这方面的东西了。 avoid generic names like tmp and retval 作者批评了tmp,retval,foo这种词语，虽然我没用过retval和foo这种奇怪的名字，但是 我却用过tmp这东西，后来想了一下，tmp这种东西的确看不出来任何含义，就算时间紧迫，我 也不会用tmp这种变量了。但是，就像作者所说的一样，对于下面的代码: void swap(int *a,int *b) { int tmp = *a; *a = b; *b = tmp; } 这时候tmp则用得恰到好处，tmp在这里生命周期非常短，而且它的作用刚好是作为临时来用的。 对于计数器变量，我们经常使用i,j,k,x,y,z,a,b,c什么的，但是，正如作者所说，当有 多个计数器变量时，这种东西就经常会让人很难看懂了。看下面的例子: for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; M; j++){ for(int k = 0; k &lt; C; k++){ if(school[i].teacher[k] == user[j]){ ...
				<a class="read-more" href="/zhengyhn.github.io/post/improve-code-readability/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/write-down-the-reStructuredText-syntax-I-frequently-use/">reStructuredText语法笔记</a></h2>
          <span class="post-date">May 27, 2016</span>
		  
		  
		  	<div class="summary">
				reStructuredText用于排版非常好。但是，和C++一样，越是灵活，越是可扩展，越是复杂。 有些语法，你永远记不住，我经常遇到一些表示方法（比如说超链接），忘记了语法，每次都 要去Google。为了不这么麻烦，我决定记下去，以免下次忘了又要去查。 大部分都来自 这里 。 代码块 在段落的结尾使用 :: 符号, 然后输入一个空行，然后是代码（必须缩进，空2格或4格）， 然后是一个空行。比如 代码如下: #include &lt;iostream&gt; int main(int argc, char *argv[]) { return 0; } 引入代码文件 对于我等码农来说，这应该算是最常用的了。格式为: .. code-include:: source-code-file :lexer: language-name 超链接 经常要引用一些大牛的博客，链接的格式为: `链接文字 &lt;链接&gt;`_ 比如， 我的英文博客 。 斜体和粗体 斜体: *这是斜体* 粗体: **这是粗体** 图片 格式是这样的: .. image:: /images/one_piece.gif :alt: one_piece :width: 200px :height: 150px :scale: 80 % :align: left align的选项是left, center, right。
				<a class="read-more" href="/zhengyhn.github.io/post/write-down-the-reStructuredText-syntax-I-frequently-use/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-08-03-a-tour-to-the-badaling-great-wall/">A tour to The Badaling Great Wall</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				Today, I went to the Badaling Great Wall alone. There is a saying that He who has never been to the Great Wall is not a true man. I had read this saying for many times when I was in high school, but I have never been to the Great Wall util today. I got up at 7:00am and began my tour at about 7:40am after the breakfast. It took me 30 minutes to arrive at Xi zhi men station from where I live.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-08-03-a-tour-to-the-badaling-great-wall/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-07-28-about-constructors-destructors-and-assignment-operators/">About Constructors Destructors and Assignment Operators</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				What functions C++ will silently write and call? If we declare an empty class, the compiler will declare a constructor, a copy constructor, a copy assignment operator and a destructor for us. class Girl { }; But the compiler is not foolish, it will only generate them when needed. What do the generated functions do? For construtor, it will invoke the corresponding constructor and non-static members of its base class. For destructor, it will invoke the corresponding destructor of its base class.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-07-28-about-constructors-destructors-and-assignment-operators/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-08-09-always-pass-parameters-by-reference-to-const/">Always pass parameters by reference-to-const</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				We all know that pass by value is not effecient.So we use pass by pointer in C.However, in C++, we prefer pass by referece-to-const. Here is an example. #include &lt;iostream&gt; #include &lt;cstdio&gt; class Dog { public: Dog() { printf(&quot;Calling Dog's constructor\n&quot;); } Dog(const Dog&amp; d) { printf(&quot;Calling Dog's copy constructor\n&quot;); this-&gt;name = d.name; } virtual ~Dog() { printf(&quot;Calling Dog's destructor\n&quot;); } private: std::string name; }; void walk_the_dog(Dog d) { } int main(int argc, char **argv) { Dog dog; walk_the_dog(dog); return 0; } The running result is as follows: Calling Dog's constructor Calling Dog's copy constructor Calling Dog's destructor Calling Dog's destructor Now, let&rsquo;s analysis this passing by value process.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-08-09-always-pass-parameters-by-reference-to-const/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-07-24-const-anyway/">Const anyway!</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				Const pointer const is versatile.I am always confused by the following syntax. const char *str = &quot;Hello&quot;; // const data, non-const pointer char * const str = &quot;Hello&quot;; // const pointer, non-const data Now there is a tip to remember it. If const appears to the right of the asterisk, the pointer is constant.If const appears to the left of the asterisk, the data is constant. So the following two statements are the same.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-07-24-const-anyway/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-08-01-cpp-resource-management/">Cpp Resource Management</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				I always forget freeing a memory that allocated from the heap.And I always forget closing the file handler. Resources include file descriptors, mutex locks, fonts, brushes, database connections and network sockets. I think less programmers can remember closing a file handler, especially in a large project. Nowadays, many programming languages have the garbage collection function. In C++, since the destructor will be automatically called, we can release the resources automatically if we put the resource into an object.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-08-01-cpp-resource-management/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-08-15-do-not-hide-inherited-names/">Do not hide inherited names</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				In inheritance, there are some rules defined by C++, one of which is that the virables or the functions in the base class will be hidden if there are virables and functions with the same name. It seems perfect, but it&rsquo;s a pitfall of C++. Consider the following example. #include &lt;cstdio&gt; #include &lt;iostream&gt; class Person { public: explicit Person() { } ~Person() { } void sleep() const { printf(&quot;Person sleep\n&quot;); } void sleep(const int sec) const { printf(&quot;Person sleep %d s\n&quot;, sec); } private: Person(const Person&amp;); const Person&amp; operator=(const Person&amp;); }; class Student:public Person { public: explicit Student() { } ~Person() { } void sleep() const { printf(&quot;Student sleep\n&quot;); } private: Student(const Student&amp;); const Student&amp; operator=(const Student&amp;); }; int main(int argc, char **argv) { Student stu; stu.sleep(); stu.sleep(1); return 0; } This program won&rsquo;t be compiled.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-08-15-do-not-hide-inherited-names/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-09-21-implement-a-bidirectional-linked-list/">Implement a bidirectional linked list</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				A bidirectional linked list is the same as a singular linked list except that there are two links between two nodes. Here is the specification of my BiLinkedList. BiLinkedList(), Create an empty BiLinkedList. BiLinkedList(const BiLinkedList&amp; list), Create a BiLinkedList from another BiLinkedList list. BiLinkedList(const T&amp; value), Create a BiLinkedList whose first element is value. BiLinkedList(const T values[], size_t size), Create a BiLinkedList from an array values of size size. const BiLinkedList&amp; operator=(const BiLinkedList&amp; list), Support BiLinkedList assignment.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-09-21-implement-a-bidirectional-linked-list/">&hellip;</a>
			</div>
		  
        </div>
        
      </div>
      <div class="pagination">
   
  <a class="btn next" href="/post/page/2/">Older</a> 
</div>
    </div>
    <div class="footer">
  <p>Powered by <a href="http://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
</div>

  </div>
  <script src="/zhengyhn.github.iojs/slim.js"></script>
  

</body>

</html>