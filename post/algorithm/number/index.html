<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>数字的算法 - Hank&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Hank" />
  <meta name="description" content="基本代数 加法 十进制有一个很傻逼但是很有趣的性质： 任意3个个位数相加的和最多是两位数 事实上，对于任意进制，都有这个性质。 另外一个很有用的性质：" />

  <meta name="keywords" content="Nodejs, Algorithm, C&#43;&#43;, Docker, NLP, Typescript, Linux, Redis, Mongodb" />






<meta name="generator" content="Hugo 0.30.2" />


<link rel="canonical" href="http://zhengyhn.github.io/post/algorithm/number/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/even.min.css?v=2.7.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">

<meta property="og:title" content="数字的算法" />
<meta property="og:description" content="基本代数 加法 十进制有一个很傻逼但是很有趣的性质： 任意3个个位数相加的和最多是两位数 事实上，对于任意进制，都有这个性质。 另外一个很有用的性质：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://zhengyhn.github.io/post/algorithm/number/" />



<meta property="article:published_time" content="2013-03-13T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2013-03-13T00:00:00&#43;00:00"/>











<meta itemprop="name" content="数字的算法">
<meta itemprop="description" content="基本代数 加法 十进制有一个很傻逼但是很有趣的性质： 任意3个个位数相加的和最多是两位数 事实上，对于任意进制，都有这个性质。 另外一个很有用的性质：">


<meta itemprop="datePublished" content="2013-03-13T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2013-03-13T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="4267">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="数字的算法"/>
<meta name="twitter:description" content="基本代数 加法 十进制有一个很傻逼但是很有趣的性质： 任意3个个位数相加的和最多是两位数 事实上，对于任意进制，都有这个性质。 另外一个很有用的性质："/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Hank&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Hank&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">数字的算法</h1>

      <div class="post-meta">
        <span class="post-time"> 2013-03-13 </span>
        
        <span class="more-meta"> 约 4267 字 </span>
        <span class="more-meta"> 预计阅读 9 分钟 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#基本代数">基本代数</a>
<ul>
<li><a href="#加法">加法</a></li>
<li><a href="#乘法和除法">乘法和除法</a></li>
</ul></li>
<li><a href="#模代数">模代数</a>
<ul>
<li><a href="#求模运算">求模运算</a></li>
<li><a href="#欧几里得最大公约数算法">欧几里得最大公约数算法</a></li>
<li><a href="#扩展欧几里得算法">扩展欧几里得算法</a></li>
</ul></li>
<li><a href="#素性测试">素性测试</a>
<ul>
<li><a href="#费马小定理">费马小定理</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="基本代数">基本代数</h1>

<h2 id="加法">加法</h2>

<p>十进制有一个很傻逼但是很有趣的性质：</p>

<pre><code class="language-example">任意3个个位数相加的和最多是两位数
</code></pre>

<p>事实上，对于任意进制，都有这个性质。 另外一个很有用的性质：</p>

<hr />

<p>对于一个基数为b的k位数，它能表示的最大数为b^k^ - 1</p>

<hr />

<p>想要知道一个基数为b的数有多少位k，则：</p>

<hr />

<p>k = log~b~(N + 1)</p>

<hr />

<h2 id="乘法和除法">乘法和除法</h2>

<p>这里出现了一种神奇的乘法算法，对于计算机来说效率非常高，
引用<a href="http://en.wikipedia.org/wiki/Multiplication_algorithm#Quarter_square_multiplication">wikipedia</a>
的例子：</p>

<pre><code class="language-example">Decimal:     Binary:
11   3       1011  11
5    6       101  110
2   12       10  1100   #will delete
1   24       1  11000
   ---          -----
    33         100001
</code></pre>

<p>算法是这样的：</p>

<ol>
<li>11除以2,取整为5;3乘以2为6</li>
<li>5除以2,取整为2;6乘以2为12</li>
<li>2除了2,为1;12乘以2为24</li>
<li>去掉2那一行，因为2是偶数。</li>
<li>最后相加：3 + 6 + 24 = 33</li>
</ol>

<p>当然，最简单的是：</p>

<pre><code class="language-example">3 11
1 22
  --
  33
</code></pre>

<p>从右边的二进制可以看到，左边的数在右移，右边的数在左移，去掉的偶数行对应的
二进制数为0,因此不用相乘。左移和右移在计算机中运算是非常快，这种办法大大
提高了乘法的效率。</p>

<p>马上用代码来实现：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* multiple two integer A and B */
int multiple(int a, int b);

int main(int argc, char *argv[])
{
    int i, j;

    for (i = -1000; i &lt; 1000; i++) {
        for (j = -1000; j &lt; 1000; j++) {
            if (multiple(i, j) == i * j) {
                printf(&quot;match!!\n&quot;);
            } else {
                printf(&quot;error!!\n&quot;);
                exit(1);
            }
        }
    }
    printf(&quot;oh!successfully!!!\n&quot;);

    return 0;
}

int multiple(int a, int b)
{
    int sign, temp, sum;

    if (a &lt; 0) {
        sign = -1;
        a = -a;
    } else {
        sign = 1;
    }
    if (b &lt; 0) {
        sign = -sign;
        b = -b;
    }
    if (a &gt; b) {
        temp = a;
        a = b;
        b = temp;
    }
    if (a == 0 || b == 0) {
        return 0;
    }

    sum = 0;
    while (a &gt;= 1) {
        if (a &amp; 1) {
            sum += b;
        }
        a &gt;&gt;= 1;
        b &lt;&lt;= 1;
    }
    if (sign == -1) {
        return -sum;
    } else {
        return sum;
    }
}
</code></pre>

<p>上面代码中，用自己写的乘法和标准的乘法来判断，看看结果有没有错。</p>

<p>同样，可以推理出来除法的算法（虽然我推不出来&hellip;），代码实现如下：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Div {
    int quot;
    int rem;
};

/* calculate DIVIDER / DIVISOR, return the quotient and remainder
 * in struct Div. */   
struct Div divide(int divider, int divisor);

int main(int argc, char *argv[])
{
    int i, j;
    struct Div d;

    for (i = -10; i &lt; 10; i++) {
        for (j = 1; j &lt; 100; j++) {
            d = divide(i, j);
            if (d.quot == i / j &amp;&amp; d.rem == i % j) {
                printf(&quot;match!!\n&quot;);
            } else {
                printf(&quot;%d / %d :error!\n&quot;, i, j);
                exit(1);
            }
        }
    }

    return 0;
}

struct Div divide(int divider, int divisor)
{
    struct Div div;
    int sign, rem_sign;

    if (divisor == 0) {
        fprintf(stderr, &quot;divisor can't be zero!&quot;);
        exit(1);
    }
    if (divider == 0) {
        div.quot = 0;
        div.rem = 0;
        return div;
    }
    if (divider &lt; 0) {
        sign = -1;
        divider = -divider;
        rem_sign = -1;
    } else {
        sign = 1;
        rem_sign = 1;
    }
    if (divisor &lt; 0) {
        sign = -sign;
        divisor = -divisor;
    }
    div.quot = div.rem = 0;
    while (divider &gt; 0) {
        if (divider &amp; 1) {
            div.rem++;
        }
        divider &gt;&gt;= 1;
        div.rem += divider;
        while (div.rem &gt;= divisor) {
            div.quot++;
            div.rem -= divisor;
        }
    }
    if (sign == -1) {
        div.quot = -div.quot;
    }
    if (rem_sign &lt; 0) {
        div.rem = -div.rem;
    }

    return div;
}
</code></pre>

<h1 id="模代数">模代数</h1>

<h2 id="求模运算">求模运算</h2>

<p>同余(congruent modulo)定理：</p>

<hr />

<p>x ≡ y (mod N) ↔ N divides (x - y)</p>

<hr />

<p>按照我个人的理解，是：</p>

<pre><code class="language-example">x和y除了N有相同的余数当且仅当N整除(x - y)
</code></pre>

<p>用书上的例子，令x = 253, y = 13, 253除以60余数为13, 13除以60余数也是13,
253 - 13 = 240, 240能被60整除。</p>

<p>下面这个图，能形象地说明这个问题：</p>

<pre><code class="language-example">... -6 -3 0 3 6 ...        //余数为0
... -5 -2 1 4 7 ...        //余数为1
... -4 -1 2 5 8 ...        //余数为2
</code></pre>

<p>对多少取模，就有多少行。</p>

<p>替换规则：</p>

<hr />

<p>如果x1 ≡ x2 (mod N),且y1 ≡ y2 (mod N)，则 x1 + y1 ≡ x2 + y2 (mod N), 且
x1 * y1 ≡ x2 * y2 (mod N)</p>

<hr />

<p>这个规则有非常重要的作用，在一些数论的题中，比如：</p>

<hr />

<p>2^345^ ≡ (2^5^)^69^ ≡ (32)^69^ ≡ (mod 31) 因为32 ≡ 1 (mod 31), 32 ≡ 1
(mod 31)，所以 32^2^ ≡ 1^2^ (mod 31), &hellip; 32^69^ ≡ 1^69^ ≡ 1 (mod 31) =
1</p>

<hr />

<p>模的幂算法：</p>

<p>比较高效的算法，来自<a href="http://en.wikipedia.org/wiki/Modular_exponentiation">wikipedia</a>
由下面的定理推出：</p>

<hr />

<p>c ≡ (a * b) (mod N) c ≡ (a * (b (mod N))) (mod N)</p>

<hr />

<p>于是：</p>

<hr />

<p>a^2^ (mod N) ≡ (a * (a (mod N))) (mod N) a^3^ (mod N) ≡ (a * ((a * (a
(mod N))) (mod N))) (mod N) &hellip;</p>

<hr />

<p>我等码农，还是用代码来实现一下吧：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

/* calculate BASE^EXP % MOD, return the result */
int mod_pow(int base, int exp, int mod);

int main(int argc, char *argv[])
{
    printf(&quot;%d\n&quot;, mod_pow(4, 13, 497));

    return 0;
}

int mod_pow(int base, int exp, int mod)
{
    int i, inter_base, result;

    result = 1;
    for (i = 0; i &lt; exp; i++) {
        inter_base = base * result;
        result = inter_base % mod;
    }
    return result;
}
</code></pre>

<p>还有一种更快的算法，类似于前面的乘法和除法。这时候，其实是
把幂看成一个二进制数，从最低位开始，如果为1则要像上面的算法一样计算结果，
否则保留原来结果，每次向高位前进的时候，基数都要翻一倍，并取模。
用代码来说明问题吧：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

/* calculate BASE^EXP % MOD, EXP &gt;= 0, return the result */
int mod_pow(int base, int exp, int mod);

int main(int argc, char *argv[])
{
    printf(&quot;%d\n&quot;, mod_pow(4, 13, 497));

    return 0;
}

int mod_pow(int base, int exp, int mod)
{
    int result;

    result = 1;
    while (exp &gt; 0) {
        if (exp &amp; 1) {
            result = (result * base) % mod;
        }
        exp &gt;&gt;= 1;
        base = (base * base) % mod;
    }

    return result;
}
</code></pre>

<p>这个算法我的理解不是很透彻，先记下来再说。</p>

<p>后来发现原来这个算法称为“蒙格马利算法”，它要用到下面的这个定理作为引理：</p>

<pre><code class="language-example">(a * b) % m = ((a % m) * (b % m)) % m
</code></pre>

<h2 id="欧几里得最大公约数算法">欧几里得最大公约数算法</h2>

<p>首先，不要忘记这个英文名，Euclid。虽然这是一个非常古老的算法，但是有的时候你还是会
忘记，因此，我要好好记住它。</p>

<pre><code class="language-example">对于两个正整数x和y，有x &gt;= y，则gcd(x, y) = gcd(x mod y, y).
</code></pre>

<p>记住容易，但是要能证明它，才是真正理解了。证明如下：</p>

<pre><code class="language-example">有2个正整数x, y, x &gt;= y, 它们的最大公约数是gcd。
令x = ky + r，则(x mod y) = r = x - ky，
假设d为x和y的一个公约数，即d能整除x，d也能整除y，
则d也能整除(x mod y)。
假设d为(x mod y)和y的一个公约数，由于x = ky + r = ky + (x mod y)，
所以d也能整除x。
因此，x和y的某个公约数等于x mod y和y对应的公约数，最大公约数当然也相等。
</code></pre>

<p>用代码来实现：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

/* return the greatest common divisor with x, y &gt;= 0,
 * implement using recursive method. */
int gcd_r(int x, int y);

/* return the greatest common divisor with x, y &gt;= 0,
 * implement using non-recursive method. */
int gcd(int x, int y);

int main(int argc, char *argv[])
{
    printf(&quot;%d\n&quot;, gcd_r(1035, 759));
    printf(&quot;%d\n&quot;, gcd(1035, 759));

    return 0;
}

int gcd_r(int x, int y)
{
    int temp;

    if (x &lt; y) {
        temp = x;
        x = y;
        y = temp;
    }
    if (y == 0) {
        return x;
    } else {
        return gcd_r(y, x % y);
    }
}

int gcd(int x, int y)
{
    int temp;

    if (x &lt; y) {
        temp = x;
        x = y;
        y = temp;
    }
    while (y &gt; 0) {
        temp = y;
        y = x % y;
        x = temp;
    }
    return x;
}
</code></pre>

<h2 id="扩展欧几里得算法">扩展欧几里得算法</h2>

<pre><code class="language-example">对于不全为0的正整数a和b，gcd(a, b)表示a和b的最大公约数，则必然存在整数对
x和y，使得gcd(a, b) = ax + by
</code></pre>

<p>上面的定义引用自<a href="http://baike.baidu.com/view/1478219.htm#2">百度百科</a></p>

<p>它的一个应用是解不定方程。引用自<a href="http://blog.csdn.net/fioman/article/details/2455698">这里</a>
, <a href="http://blog.csdn.net/lhfight/article/details/7755994">这篇文章</a>
解决了我的一些迷惑。</p>

<pre><code class="language-example">对于不定方程ax + by = c，已经a, b, c的值，求解满足方程的一组x, y。
其中a, b, c, x, y都是整数。
</code></pre>

<p>判断有无解的方法：如果c不是gcd(a, b)的倍数，则无解，否则有解。</p>

<p>求解的方法：</p>

<p>假设ax~1~ + by~1~ = gcd(a, b), 两边除以gcd(a, b)，得到</p>

<p>ax~1~ / gcd(a, b) + by~1~ / gcd(a, b) = 1，两边再同时乘以c，得到：</p>

<p>ax~1~ * (c / gcd(a, b)) + by~1~ * (c / gcd(a, b)) = c = ax + by,</p>

<p>于是:</p>

<p>x = x1 * (c / gcd(a, b))</p>

<p>y = y1 * (c / gcd(a, b))</p>

<p>这样，求x, y就转化成为求x1和y1了。</p>

<p>现在再来看看怎么求x1和y1。</p>

<p>如果b = 0, 则gcd(a, b) = a，由ax1 + by1 = gcd(a, b) = a，得</p>

<p>x1 = 1, y1为任意整数，比如y1 = 0。</p>

<p>如果b不为0, 则有：</p>

<p>ax1 + by1 = gcd(a, b) = gcd(b, a % b) = bx2 + (a % b)y2</p>

<p>= bx2 + (a - (a / b) * b)y2 = bx2 + ay2 - (a / b) * b * y2</p>

<p>于是有：</p>

<p>x1 = y2, y1 = x2 - (a / b)y2</p>

<p>因此，只要求出x2和y2，就能求出x1和y1了。这样类推下去，直到b =
0，便能得到 一组解，最后可以求出x1和y1，然后就可以求出x和y了。</p>

<p>废话少说，马上上代码：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

/* extended euclidean algorithm:gcd(a, b) = ax + by
 * return gcd(a, b) */   
int extended_euclid(int a, int b, int *x, int *y);

/* solve the indefinite equation: ax + by = c,
 * if no solution, return 0, otherwise return 1
 * and set one solution in x and y. */
int indefinite_equation(int a, int b, int c, int *x, int *y);

int main(int argc, char *argv[])
{
    int x, y;

    if (indefinite_equation(2, 3, 8, &amp;x, &amp;y)) {
        printf(&quot;x=%d, y=%d\n&quot;, x, y);
    }

    return 0;
}

int indefinite_equation(int a, int b, int c, int *x, int *y)
{
    int gcd;

    gcd = extended_euclid(a, b, x, y);
    if (c % gcd != 0) {
        return 0;
    }
    *x = *x * (c / gcd);
    *y = *y * (c / gcd);
    return 1;
}

int extended_euclid(int a, int b, int *x, int *y)
{
    int x1, y1, gcd;

    if ( b == 0) {
        *x = 1;
        *y = 0;
        return a;
    }
    gcd = extended_euclid(b, a % b, &amp;x1, &amp;y1);
    *x = y1;
    *y = x1 - (a / b) * y1;

    return gcd;
}
</code></pre>

<p>它的另外一个应用是求解模的乘法逆元(multiplicative inverse)。
对于我这种数学白痴，还是先来了解一下乘法逆元是个什么东西好了，引用自<a href="http://en.wikipedia.org/wiki/Modular_multiplicative_inverse">wikipedia</a>
。</p>

<p>整数a模m的乘法逆元是一个整数x，如果它们满足：</p>

<p>a^-1^ ≡ x (mod m)</p>

<p>也可以写成：</p>

<p>ax ≡ aa^-1^ ≡ 1 (mod m)</p>

<p>a的乘法逆元存在当且仅当a与m互质。</p>

<p>好，了解完之后，再来看看怎么运用扩展欧几里得算法来求a模m的乘法逆元。</p>

<p>要求a模m的乘法逆元x，有：</p>

<p>ax ≡ 1 (mod m)</p>

<p>即ax和1对m同余，且余数肯定为1,于是存在整数q，使得：</p>

<p>ax = qm + 1</p>

<p>于是，有：</p>

<p>ax - mq = 1</p>

<p>这个式子有点类似扩展欧几里得算法里面的</p>

<p>ax + by = gcd(a, b)</p>

<p>这个式子了。</p>

<p>这里，a和m是已知的，gcd(a, m)为右边的1,q又是没有用的。</p>

<p>代码实现非常简单，用到了上例中的扩展欧几里得算法的函数：</p>

<pre><code class="language-c">/* calculate the multiplicative inverse of (a mod m), return
 * the inverse */   
int mul_inverse(int a, int m);

int mul_inverse(int a, int m)
{
    int inverse, y;

    extended_euclid(a, m, &amp;inverse, &amp;y);

    return inverse;
}
</code></pre>

<p>最后，感谢<a href="http://www.cppblog.com/zoyi-zhang/articles/44811.html">这篇文章</a>
帮助我理解乘法逆元。</p>

<h1 id="素性测试">素性测试</h1>

<p>primality testing. 合数的英文是composite.</p>

<h2 id="费马小定理">费马小定理</h2>

<p>fermat&rsquo;s little theorem：</p>

<p>如果p是质数，则对于所有的1 ≤ a &lt; p, 有</p>

<p>a^p-1^ ≡ 1 (mod p)</p>

<p>如果a是任意整数，则有：</p>

<p>a^p^ ≡ a (mod p), 也可以写成：</p>

<p>a^p^ - a ≡ 0 (mod p)</p>

<p>即a^p^ - a是p的倍数。</p>

<p>这个定理的主要应用是进行素性测试。</p>

<p>先来看一下怎么判断一个正整数是不是素数。</p>

<p>最直接的做法,使用定义来判断：</p>

<pre><code class="language-example">typedef unsigned int uint;

/* judge whether an integer N is prime
 * in terms of the definition. */   
int is_prime_direct(uint n);

int is_prime_direct(uint n)
{
    int i;

    if (n &lt; 2) {
        return 0;
    }
    for (i = 2; i &lt; n; i++) {
        if (n % i == 0) {
            return 0;
        }
    }
    return 1;
}
</code></pre>

<p>这个方法是从2到n-1遍历一次，看n能不能被其中一个数整除，事实上，当遍历
超过n / 2的时候，就可以确定看来的数不可能整除n了，于是，可以提高一倍的
速度。</p>

<pre><code class="language-c">typedef unsigned int uint;

/* judge whether an integer N is prime
 * in terms of the definition and stop
 * at n / 2. */   
int is_prime_half(uint n);

int is_prime_half(uint n)
{
    int i;

    if (n &lt; 2) {
        return 0;
    }
    for (i = 2; i &lt;= n / 2; i++) {
        if (n % i == 0) {
            return 0;
        }
    }
    return 1;
}   
</code></pre>

<p>我们再来想一下，如果要判断53是不是素数，发现：</p>

<p>51不能被2整除，53 / 2 = 26，余数为1</p>

<p>53不能被3整除，53 / 3 = 17，余数为2</p>

<p>&hellip;</p>

<p>53 不能被17整除, 53 / 17 = 3，余数为2</p>

<p>&hellip;</p>

<p>53不能被26整除，53 / 26 = 2，余数为1</p>

<p>可以看出来有重复了，事实上判断2和判断26是一样的，判断3和判断17也是一样的，
我们做了很多重复工作，事实上只要判断到√53 就行了，因为后面的判断和前面是
重复的。于是，就可以写出来更快的算法，速度又有了质的提高。</p>

<pre><code class="language-c">#include &lt;math.h&gt;

typedef unsigned int uint;

/* judge whether an integer N is prime
 * in terms of the definition and stop
 * at sqrt(n). */   
int is_prime_sqrt(uint n);

int is_prime_sqrt(uint n)
{
    int i;

    if (n &lt; 2) {
        return 0;
    }
    for (i = 2; i &lt;= sqrt(n); i++) {
        if (n % i == 0) {
            return 0;
        }
    }
    return 1;
}   
</code></pre>

<p>现在我们就可以用费马小定理来测试素数了，比如要判断正整数n是不是素数，
我们可以在{1, &hellip;, n - 1}中随机取一个数a来测试，如果</p>

<p>a^n-1^ ≡ 1 (mod n)</p>

<p>则n可能是一个素数。说是可能，因为有一些合数也能通过费马测试，这些数被称为
carmichael number(卡迈克尔数)，但是这些数出现的概率非常低。</p>

<p>这里影响效率的操作主要是计算a^(n-1)^ mod
n，还好我们有前面的快速求幂模法（也 称蒙格马利法）。</p>

<p>继续上代码：</p>

<pre><code class="language-c">/* judge whether an integer N is prime
 * in terms of fermat's little theorem */
int is_prime_fermat(uint n);

/* calculate BASE^EXP % MOD, return the result */
int pow_mod(int base, int exp, int mod);

int is_prime_sqrt(uint n)
{
    int i;

    if (n &lt; 2) {
        return 0;
    }
    for (i = 2; i &lt;= sqrt(n); i++) {
        if (n % i == 0) {
            return 0;
        }
    }
    return 1;
}   

int is_prime_fermat(uint n)
{
    int base;

    if (n &lt; 2) {
        return 0;
    }
    base = rand() % (n - 1) + 1;
    if (pow_mod(base, n - 1, n) == 1) {
        return 1;
    } else {
        return 0;
    }
}

int pow_mod(int base, int exp, int mod)
{
    int result;

    result = 1;
    while (exp &gt; 0) {
        if (exp &amp; 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp &gt;&gt;= 1;
    }
    return result;
}
</code></pre>

<p>我测试了一下，在判断1000以内的素数时，有12个合数被误以为是素数，说明概率还
是挺大的，因为我们还没有优化。</p>

<p>如果我们随机拿多个数a来测试，则会大大降低错误率。比如我取n /
2个数来测试。</p>

<pre><code class="language-c">int is_prime_fermat(uint n)
{
    int base, i;

    if (n &lt; 2) {
        return 0;
    }
    for (i = 0; i &lt; n / 2; i++) {
        base = rand() % (n - 1) + 1;
        if (pow_mod(base, n - 1, n) != 1) {
            return 0;
        }
    }
    return 1;
}
</code></pre>

<p>这次我测试1000以内的素数就全部正确了。</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Hank</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2013-03-13</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/images/wechat.jpg">
        <span>微信打赏</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/images/alipay.jpg">
        <span>支付宝打赏</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/test/config_comp.org/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">配置测试与兼容性测试</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/pm/intro.org/">
            <span class="next-text nav-default">简介</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:yuanhang.zheng@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/zhengyhn" class="iconfont icon-github" title="github"></a>
  <a href="http://zhengyhn.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    &copy; 
    2017
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Hank</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=2.7.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>




</body>
</html>
