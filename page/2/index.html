<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> Hank&#39;s Blog &middot; Hank&#39;s Blog </title>


<link rel="stylesheet" href="/zhengyhn.github.io/css/slim.css">
<link rel="stylesheet" href="/zhengyhn.github.io/css/highlight.min.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="zhengyhn.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Hank&#39;s Blog" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="/zhengyhn.github.io">Hank&#39;s Blog</a></h1>
  <p class="site-tagline">坚持做一件事，然后静静地等待时间的回报</p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
       
	  <li class="spacer">&ac;</li>
  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="posts">
         
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-10-03-implement-a-binary-search-tree/">Implement a binary search tree</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				A binary search tree is very useful in solving the real world problems. The red-black tree is one kind of binary search tree. For more information about binary search tree, please visit the wikipedia. Here is the specification of my binary search tree. BinarySearchTree(), Create an empty binary search tree. BinarySearchTree(const T&amp; root_val), Create an binary search tree whose root node is constructed from root_val. BinarySearchTree(const T values[], const size_t&amp; size), Create an binary search tree from an array values.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-10-03-implement-a-binary-search-tree/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-09-21-implement-a-circular-linked-list/">Implement a circular linked list</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				A circular linked list is the same as a singular linked list except that there last node points to the first node. Here is the specification of my CiLinkedList. CiLinkedList(), Create an empty CiLinkedList. CiLinkedList(const CiLinkedList&amp; list), Create a CiLinkedList from another CiLinkedList list. CiLinkedList(const T&amp; value), Create a CiLinkedList whose first element is value. CiLinkedList(const T values[], size_t size), Create a CiLinkedList from an array values of size size. const CiLinkedList&amp; operator=(const CiLinkedList&amp; list), Support CiLinkedList assignment.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-09-21-implement-a-circular-linked-list/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-09-25-implement-a-queue/">Implement a queue</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				A queue is based on the Linked List. The most explicit feature of a queue is FIFO(First in first out). Here is the specification of my Queue. Queue(), Create an empty queue. Queue(const T&amp; value), Create a queue whose first element is value. Queue(const T values[], const size_t&amp; size), Create a queue from an array values whose size is size. Queue(const Queue&lt;T&gt;&amp; queue), Create a queue from another queue. const Queue&lt;T&gt;&amp; operator=(const Queue&lt;T&gt;&amp; queue), Support queue assignment.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-09-25-implement-a-queue/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-09-27-implement-a-queue-using-two-stacks/">Implement a queue using two stacks</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				A queue can be implemented using two stacks. One stack store the elements appended to the queue. The other stack store the elements to be popped from the queue. Here is the specification of my Queue. StQueue(), Create an empty queue. StQueue(const T&amp; value), Create a queue whose first element is value. StQueue(const T values[], const size_t&amp; size), Create a queue from an array values whose size is size. StQueue(const StQueue&lt;T&gt;&amp; queue), Create a queue from another queue.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-09-27-implement-a-queue-using-two-stacks/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-09-12-implement-a-singular-linkedlist/">Implement a singular LinkedList</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				LinkedList is a very common data structure. Three years ago, I could write a singular LinkedList very quickly in C/C++. But the code is ugly and very ineffecient. Now I am going to implement a singular LinkedList in C++ in order to cracking the interview. Here is the specification of my LinkedList. LinkedList(), Create an empty LinkedList. LinkedList(const LinkedList&amp; list), Create a LinkedList from another LinkedList list. LinkedList(const T&amp; value), Create a LinkedList whose first element is value.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-09-12-implement-a-singular-linkedlist/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-09-26-implement-a-stack/">Implement a stack</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				A stack is based on the Linked List. The most explicit feature of a stack is FILO(First in last out). Here is the specification of my Stack. Stack(), Create an empty stack. Stack(const T&amp; value), Create a stack whose first element is value. Stack(const T values[], const size_t&amp; size), Create a stack from an array values whose size is size. Stack(const Stack&lt;T&gt;&amp; stack), Create a stack from another stack. const Stack&lt;T&gt;&amp; operator=(const Stack&lt;T&gt;&amp; stack), Support stack assignment.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-09-26-implement-a-stack/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-09-26-implement-the-sorting-algorithms/">Implement the sorting algorithms</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				The sorting algorithms are very important in programming interview. I have to be able to write them on a paper without even an error. Bubble Sort The immediate thought of bubble sort is that swapping the ajacent elements if they are of the wrong order in each pass until there are no swapping. For example, consider the array [5, 1, 4, 2, 8], First pass: [5, 1, 4, 2, 8] =&gt; [1, 5, 4, 2, 8] =&gt; [1, 4, 5, 2, 8] =&gt; [1, 4, 2, 5, 8] =&gt; [1, 4, 2, 5, 8] Second pass: [1, 2, 4, 5, 8] =&gt; [1, 2, 4, 5, 8] =&gt; [1, 2, 4, 5, 8] =&gt; [1, 2, 4, 5, 8] =&gt; [1, 2, 4, 5, 8] Third pass: [1, 2, 4, 5, 8] =&gt; [1, 2, 4, 5, 8] =&gt; [1, 2, 4, 5, 8] =&gt; [1, 2, 4, 5, 8] =&gt; [1, 2, 4, 5, 8] Here we found that the array has been sorted after the second pass, but we have apply the third pass so that we can know the array has been sorted because there are no swapping in that pass.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-09-26-implement-the-sorting-algorithms/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-07-26-initialized-before-used/">Initialized before used</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				For constructor In the constructor, the statements in the body are assignments, not initializations. #include &lt;iostream&gt; class Girl { public: Girl(std::string name, int age) { name_ = name; // These are assignments, not initilizations. age_ = age; } private: std::string name_; int age_; }; If you do this, the program will be very slow.When calling the constructor, the program will call the default construtors to initialize the members, and then enter the body of the constructor.Therefor, all the work performed in the default constructors were wasted.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-07-26-initialized-before-used/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-07-23-more-consts-enums-inlines-and-less-defines/">More consts enums inlines and less #defines</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				This is an old topic. For constants Consider a macro below. #define PI 3.14 There are several drawbacks when using a macro. It&rsquo;s hard to debug.As we all know, the macros are resolved by the preprocessor and the compiler know nothing about them.When you get an error when compiling the program, the error message may refer to 3.14 but not PI because PI is not in the symbol table. It will result in more object codes.When the preprocessor replace PI with 3.14, there will be several copy of 3.14 in the object code.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-07-23-more-consts-enums-inlines-and-less-defines/">&hellip;</a>
			</div>
		  
        </div>
        
        <div class="post">
          <h2 class="post-title"><a href="/zhengyhn.github.io/post/2013-09-25-my-c-plus-plus-coding-style/">My C&#43;&#43; coding style</a></h2>
          <span class="post-date">May 14, 2016</span>
		  
		  
		  	<div class="summary">
				Every programmer has his/her own coding style. Time goes by, and my coding style is changing. There following is my note on c++ coding style. I will explain why I want to coding in that style. Why do I care about my coding style so much? Because I am a virgo. Always add a m_ prefix to the members and use this to refer to other member functions in the member function.
				<a class="read-more" href="/zhengyhn.github.io/post/2013-09-25-my-c-plus-plus-coding-style/">&hellip;</a>
			</div>
		  
        </div>
        
      </div>
      <div class="pagination">
  
  <a class="btn previous" href="/">Newer</a>  
  <a class="btn next" href="/page/3/">Older</a> 
</div>
    </div>
    <div class="footer">
  <p>Powered by <a href="http://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
</div>

  </div>
  <script src="/zhengyhn.github.io/js/slim.js"></script>
  

</body>

</html>