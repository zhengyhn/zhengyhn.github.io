<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Hank&#39;s Blog</title>
    <link>http://zhengyhn.github.io/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Hank&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 May 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://zhengyhn.github.io/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>container-with-most-water</title>
      <link>http://zhengyhn.github.io/post/leetcode/container-with-most-water/</link>
      <pubDate>Sun, 27 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://zhengyhn.github.io/post/leetcode/container-with-most-water/</guid>
      <description>题目 Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.</description>
    </item>
    
    <item>
      <title>N皇后问题</title>
      <link>http://zhengyhn.github.io/post/leetcode/n-queens/</link>
      <pubDate>Sun, 21 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://zhengyhn.github.io/post/leetcode/n-queens/</guid>
      <description>题目 The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens&#39; placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. For example, There exist two distinct solutions to</description>
    </item>
    
    <item>
      <title>sqrtx 求整数平方根</title>
      <link>http://zhengyhn.github.io/post/leetcode/sqrtx/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://zhengyhn.github.io/post/leetcode/sqrtx/</guid>
      <description>题目 Implement int sqrt(int x). Compute and return the square root of x. x is guaranteed to be a non-negative integer. 我的思路 我能想到的只有暴力方法，从一个位置开始，一步一步加一，直到找到平方根。 代码 int mySqrt(int x) { long long times</description>
    </item>
    
    <item>
      <title>Brent判圈算法学习</title>
      <link>http://zhengyhn.github.io/post/algorithm/brent.loop/</link>
      <pubDate>Sat, 06 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://zhengyhn.github.io/post/algorithm/brent.loop/</guid>
      <description>判断一个链接有没有环，很著名的算法是Floyd判圈算法，也叫龟兔算法。但是，原来还有一种算法，可以比Floyd更快一点，这种算法叫做Bren</description>
    </item>
    
    <item>
      <title>find-all-duplicates-in-an-array</title>
      <link>http://zhengyhn.github.io/post/leetcode/find-all-duplicates-in-an-array/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://zhengyhn.github.io/post/leetcode/find-all-duplicates-in-an-array/</guid>
      <description>题目 Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? Example: Input: [4,3,2,7,8,2,3,1] Output: [2,3] 思路 想了好久，终于想出来了。首先，题目</description>
    </item>
    
    <item>
      <title>battelships-in-a-board</title>
      <link>http://zhengyhn.github.io/post/leetcode/battelships-in-a-board/</link>
      <pubDate>Sat, 23 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://zhengyhn.github.io/post/leetcode/battelships-in-a-board/</guid>
      <description>题目 Given an 2D board, count how many battleships are in it. The battleships are represented with &#39;X&#39;s, empty slots are represented with &#39;.&#39;s. You may assume the following rules: You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N</description>
    </item>
    
    <item>
      <title>array-partition-i</title>
      <link>http://zhengyhn.github.io/post/leetcode/array-partition-i/</link>
      <pubDate>Sun, 17 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://zhengyhn.github.io/post/leetcode/array-partition-i/</guid>
      <description>题目 Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range</description>
    </item>
    
    <item>
      <title>merge-two-binary-trees 合并二叉树</title>
      <link>http://zhengyhn.github.io/post/leetcode/merge-two-binary-trees/</link>
      <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://zhengyhn.github.io/post/leetcode/merge-two-binary-trees/</guid>
      <description>题目 Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will</description>
    </item>
    
    <item>
      <title>maxiumn-subarray 和最大的子数组</title>
      <link>http://zhengyhn.github.io/post/leetcode/maxiumn-subarray/</link>
      <pubDate>Sun, 10 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://zhengyhn.github.io/post/leetcode/maxiumn-subarray/</guid>
      <description>题目 Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2, 1, -3, 4, -1, 2, 1, -5, 4], the contiguous subarray [4, -1, 2, 1] has the largest sum = 6. 思路一 首先，可以直接两重循环，找到所有的子数组，</description>
    </item>
    
  </channel>
</rss>